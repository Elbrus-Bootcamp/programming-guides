# Управляемые компоненты React

Контролируемые (управляемые) и неконтролируемые (неуправляемые) инпуты — это два разных подхода к управлению состоянием формы в React.

## 1. Неконтролируемые инпуты (Uncontrolled Inputs)

Неконтролируемый инпут управляется самим DOM. Мы не храним и не отслеживаем значение инпута в состоянии компонента, а получаем его только по необходимости, например, при отправке формы, при клике по кнопке или какому-то другому событию.

### Получение из события

Ниже пример получения данных из неуправляемого инпута при отправке формы.

#### Шаги:

1. Описать форму `<form>`, текстовые поля `<input>` и кнопку отправки `<button>`
2. У текстовых полей задать атрибут `name`, чтобы данные считались `<input name="message" />`
3. Прописать атрибут `type` у кнопки `<button type="submit">Отправить</button>`
4. Создать функцию-обработчик (например, `handleSubmit`) и передать её в атрибут `onSubmit`.
5. В колбеке `handleSubmit` принять в аргументах событие отправки формы `event` и описать логику по сбору данных
6. Получить данные из события можно через конструктор `new FormData` и метод `Object.fromEntries`

#### Пример неконтролируемого инпута:

```jsx
import React from "react";

export default function UncontrolledInput() {
  // создаём обработчик отправки формы
  const handleSubmit = (event) => {
    // event - событие (в данном случае отправки формы)
    event.preventDefault(); // предотвращает перезагрузку страницы
    const formData = new FormData(event.target); // получили данные из формы
    const data = Object.fromEntries(formData); // создали объект из данных формы
    console.log("Отправка данных из формы:", data);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" name="message" />
      <button type="submit">Отправить</button>
    </form>
  );
}
```

### Получение из ref

Для работы с неконтролируемыми инпутами можно также использовать `ref`.

#### Шаги:

1. Описать форму `<form>`, текстовые поля `<input>` и кнопку отправки `<button>`
2. Создать `inputRef` с помощью хука `useRef` и повесить его на текстовое поле `<input ref={inputRef} />`
3. Прописать атрибут `type` у кнопки `<button type="submit">Отправить</button>`
4. Создать функцию-обработчик (например, `handleSubmit`) и передать её в атрибут `onSubmit`.
5. В колбеке `handleSubmit` принять в аргументах событие отправки формы `event` и описать логику по сбору данных
6. Получить данные через `inputRef.current.value`

#### Пример неконтролируемого инпута:

```jsx
import React, { useRef } from "react";

export default function UncontrolledInput() {
  // Создаём ref для получения доступа к DOM элементу
  const inputRef = useRef(null);

  // создаём обработчик отправки формы
  const handleSubmit = (e) => {
    // e - событие (в данном случае отправки формы)
    e.preventDefault(); // предотвращает перезагрузку страницы
    console.log(`Значение в текстовом поле: ${inputRef.current.value}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" ref={inputRef} />
      <button type="submit">Отправить</button>
    </form>
  );
}
```

#### Как это работает:

- `useRef` создаёт референс на DOM-элемент, который мы можем использовать для доступа к значению инпута.
- Значение инпута не хранится в состоянии компонента, а получаем его непосредственно из DOM при отправке формы.

## 2. Контролируемые инпуты (Controlled Inputs)

Контролируемый инпут — это инпут, значение которого хранится в состоянии (state) компонента. Это позволяет легко управлять состоянием инпута, отслеживать изменения и использовать данные в других частях приложения.

Для отслеживания управляемого инпута не требуется форма или кнопка `type="submit"`. Благодаря переменной состояния, React всегда следит за значением переменной и отображаемым текстовым полем.

### Управление через состояние

Ниже описаны шаги, как сделать текстовое поле управляемым

#### Шаги

1. Описать текстовые поля `<input>`
2. Объявить состояние через хук `useState`.
   1. Хук принимает начальное значение для состояния
   2. Хук возвращает массив, где первый элемент -- переменная состояниия, а второй -- функция изменения состояния.

```js
const [inputValue, setInputValue] = useState("");
```

3. Передать атрибуты на текстовое поле:
   1. `value={inputValue}` чтобы заставить инпут отображать значение переменной `inputValue`
   2. `onChange={(e) => setInputValue(e.target.value)}` чтобы изменение инпута сохранялось в переменную состояния `inputValue`

#### Пример контролируемого инпута:

```jsx
import React, { useState } from "react";

export default function ControlledInput() {
  // Объявляем состояние inputValue с начальным значением "" (пустая строка)
  const [inputValue, setInputValue] = useState("");
  // Хук useState всегда возвращает массив из 2 элементов: переменная состояния и функция, изменяющая состояние

  return (
    <div>
      <input
        type="text"
        value={inputValue} // заставляем инпут отображать значение переменной inputValue
        onChange={(e) => setInputValue(e.target.value)} // записываем изменение текста в переменную состояния
      />
    </div>
  );
}
```

#### Пример с созданием колбека

```jsx
import React, { useState } from "react";

export default function ControlledInput() {
  // Объявляем состояние inputValue с начальным значением "" (пустая строка)
  const [inputValue, setInputValue] = useState("");

  // Создаём колбек-функцию для события изменения инпута
  const handleChange = (event) => setInputValue(event.target.value);
  return (
    <div>
      <input
        type="text"
        value={inputValue} // заставляем инпут отображать значение переменной inputValue
        onChange={handleChange} // записываем изменение текста в переменную состояния
      />
    </div>
  );
}
```

#### Как это работает:

- Значение инпута (`inputValue`) хранится в состоянии компонента с помощью `useState`.
- Каждый раз, когда пользователь вводит данные, вызывается `handleChange`, который обновляет состояние компонента.
- Инпут всегда отображает текущее значение состояния, что делает его контролируемым.

## 3. Управление группой инпутов

В случае, когда форма содержит несколько инпутов, мы можем управлять их значениями через объект состояния, где ключами будут имена инпутов, а значениями — их текущие данные.

### Как сделать управляемую группу

1. Описать форму `<form>`, текстовые поля `<input>`
2. У каждого текстового поля задать уникальный атрибут `name`, например `<input name="email" /><input name="password" />`
3. Объявить состояние через хук `useState`
   1. Хук принимает начальное значение для состояния -- объект
      1. Ключи объекта состоят из атрибутов `name`
      2. Значения объекта -- пустые строки
   2. Хук возвращает массив, где первый элемент -- переменная состояниия (объект), а второй -- функция изменения состояния

```js
const [formData, setFormData] = useState({ name: "", email: "", password: "" });
```

4. Создать обработчик события изменения:

```js
const changeHandler = (event) =>
  setFormData((prev) => ({ ...prev, [event.target.name]: event.target.value }));
```

5. Передать атрибуты на текстовое поле:
   1. `value={formData.message}` (или другие ключи объекта)
   2. `onChange={changeHandler}`

#### Пример управления группой инпутов:

```jsx
import React, { useState } from "react";

export default function GroupedInputs() {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    password: "",
  });

  const handleChange = (e) =>
    setFormData((prev) => ({ ...prev, [e.target.name]: e.target.value }));

  return (
    <form>
      <input
        type="text"
        name="name" // это ключ в объекте состояния formData
        value={formData.name} // значение для отображения
        onChange={handleChange} // изменение состояния
      />
      <input
        type="email"
        name="email" // это ключ в объекте состояния formData
        value={formData.email} // значение для отображения
        onChange={handleChange} // изменение состояния
      />
      <input
        type="password"
        name="password" // это ключ в объекте состояния formData
        value={formData.password} // значение для отображения
        onChange={handleChange} // изменение состояния
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Как это работает:

- Вся информация формы хранится в объекте `formData`.
- Каждое поле формы связано с соответствующим ключом в `formData`.
- `handleChange` обновляет состояние для каждого конкретного поля, используя имя инпута (`name`).

### Заключение

Контролируемые инпуты предоставляют больше гибкости и контроль над пользовательскими данными, особенно когда нужно динамически изменять состояние или валидировать данные в режиме реального времени. Неконтролируемые инпуты проще в настройке, но их возможности ограничены, и они подходят для простых сценариев, когда управление состоянием инпута не требуется.
